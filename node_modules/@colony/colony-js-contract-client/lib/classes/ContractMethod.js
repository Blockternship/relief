'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _colonyJsUtils = require('@colony/colony-js-utils');

var _ContractClient = require('./ContractClient');

var _ContractClient2 = _interopRequireDefault(_ContractClient);

var _paramConversion = require('../modules/paramConversion');

var _paramValidation = require('../modules/paramValidation');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Abstract class for interacting with contract methods.
 */

/* eslint-disable no-underscore-dangle */

var ContractMethod = function () {
  (0, _createClass3.default)(ContractMethod, null, [{
    key: '_applyDefaultValues',


    /**
     * Given input values, method parameters and default values, iterate through
     * the parameters and construct and object with the properties from the
     * input values (if they are defined) or default values.
     */
    value: function _applyDefaultValues(inputValues) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var defaultValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      // XXX it's possible to do this in a more succinct way, but adding
      // properties in this way preserves type safety
      var values = Object.assign({}, inputValues);
      params.forEach(function (_ref) {
        var _ref2 = (0, _slicedToArray3.default)(_ref, 1),
            name = _ref2[0];

        values[name] = Object.hasOwnProperty.call(values, name) ? values[name] : defaultValues[name];
      });
      return values;
    }
  }]);

  function ContractMethod() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        client = _ref3.client,
        defaultValues = _ref3.defaultValues,
        functionName = _ref3.functionName,
        name = _ref3.name,
        input = _ref3.input,
        output = _ref3.output;

    (0, _classCallCheck3.default)(this, ContractMethod);

    this.name = name;
    this.client = client;
    this.input = input;
    this.functionName = functionName;
    this.assertValid = (0, _colonyJsUtils.makeAssert)('Validation failed for ' + name);
    if (defaultValues) this.defaultValues = defaultValues;
    if (output) this.output = output;
  }

  /**
   * Given named input values, transform these with the expected parameters
   * in order to get an array of arguments expected by the contract function.
   */

  /**
   * Given arguments to call the contract method with, return
   * transaction data as a hex string.
   */


  (0, _createClass3.default)(ContractMethod, [{
    key: 'createTransactionData',
    value: function createTransactionData(callArgs) {
      return this.client.createTransactionData(this.functionName, callArgs);
    }

    /**
     * Given input values, apply default values and validate them against the
     * expected params
     */

  }, {
    key: 'validate',
    value: function validate(inputValues) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.input;
      var defaultValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.defaultValues;

      var values = this.constructor._applyDefaultValues(inputValues, params, defaultValues);
      return (0, _paramValidation.validateParams)(values, params, this.assertValid);
    }

    /**
     * Given input values, map them against the expected parameters,
     * with the appropriate conversion for each type.
     */

  }, {
    key: 'convertInputValues',
    value: function convertInputValues(inputValues) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.input;

      return (0, _paramConversion.convertInputValues)(inputValues, params);
    }

    /**
     * Given the result of a contract method call, transform these with the
     * expected output parameters in order to get named output values as the
     * method's `OutputValues`.
     */

  }, {
    key: 'convertOutputValues',
    value: function convertOutputValues(callResult,
    // eslint-disable-next-line no-unused-vars
    inputValues) {
      var values = [].concat(callResult);

      var parsedResult = this.output.reduce(function (acc, _ref4, index) {
        var _ref5 = (0, _slicedToArray3.default)(_ref4, 1),
            name = _ref5[0];

        return Object.assign(acc, (0, _defineProperty3.default)({}, name, values[index]));
      }, {});

      return (0, _paramConversion.convertOutputValues)(parsedResult, this.output);
    }

    /**
     * Given input values, get default values, then validate them and return
     * parsed method args.
     */

  }, {
    key: 'getValidatedArgs',
    value: function getValidatedArgs(inputValues) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.input;
      var defaultValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.defaultValues;

      var values = this.constructor._applyDefaultValues(inputValues, params, defaultValues);
      this.validate(values, params);

      return params && params.length ? this.convertInputValues(values, params) : [];
    }
  }]);
  return ContractMethod;
}();

exports.default = ContractMethod;
//# sourceMappingURL=ContractMethod.js.map