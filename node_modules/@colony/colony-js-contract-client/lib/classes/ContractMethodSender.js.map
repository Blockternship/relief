{"version":3,"sources":["../../src/classes/ContractMethodSender.js"],"names":["ContractMethodSender","defaultGasLimit","eventHandlers","rest","_defaultGasLimit","inputValues","args","getValidatedArgs","client","estimate","functionName","options","_send","transaction","timeoutMs","getEventData","events","transactionHash","hash","eventData","adapter","getTransactionReceipt","receipt","successful","status","meta","eventDataPromise","receiptPromise","successfulPromise","Promise","resolve","reject","toString","callArgs","_getDefaultSendOptions","waitForMining","transactionOptions","_sendTransaction","_sendWithWaitingForMining","_sendWithoutWaitingForMining","send","networkName","provider","name","minutes","Object","assign","gasLimit"],"mappings":"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","file":"ContractMethodSender.js","sourcesContent":["/* @flow */\n\nimport BigNumber from 'bn.js';\nimport { raceAgainstTimeout } from '@colony/colony-js-utils';\n\nimport type {\n  EventHandlers,\n  Transaction,\n  TransactionOptions,\n} from '@colony/colony-js-adapter';\n\nimport ContractClient from './ContractClient';\nimport ContractMethod from './ContractMethod';\nimport type {\n  ContractResponse,\n  ContractMethodArgs,\n  SendOptions,\n} from '../flowtypes';\n\nexport default class ContractMethodSender<\n  InputValues: { [inputValueName: string]: any },\n  OutputValues: { [outputValueName: string]: any },\n  IContractClient: ContractClient,\n> extends ContractMethod<InputValues, OutputValues, IContractClient> {\n  eventHandlers: EventHandlers;\n  _defaultGasLimit: ?number;\n\n  constructor({\n    defaultGasLimit,\n    eventHandlers,\n    ...rest\n  }: ContractMethodArgs<IContractClient> & {\n    eventHandlers?: EventHandlers,\n    defaultGasLimit?: number,\n  }) {\n    super(rest);\n    if (defaultGasLimit) this._defaultGasLimit = defaultGasLimit;\n    if (eventHandlers) this.eventHandlers = eventHandlers;\n  }\n\n  /**\n   * Given named input values, call the method's contract function in\n   * order to get a gas estimate for calling it with those values.\n   */\n  async estimate(inputValues: InputValues): Promise<BigNumber> {\n    const args = this.getValidatedArgs(inputValues);\n    return this.client.estimate(this.functionName, args);\n  }\n\n  /**\n   * Given named input values and options for sending a transaction, create a\n   * transaction which calls the method's contract function with those\n   * values as transformed parameters, and collect the transaction receipt\n   * and (optionally) event data.\n   */\n  async send(\n    inputValues: InputValues,\n    options: SendOptions,\n  ): Promise<ContractResponse<OutputValues>> {\n    const args = this.getValidatedArgs(inputValues);\n    return this._send(args, options);\n  }\n\n  async _sendWithWaitingForMining(\n    transaction: Transaction,\n    timeoutMs: number,\n  ): Promise<ContractResponse<OutputValues>> {\n    const eventData = await this.client.getEventData({\n      events: this.eventHandlers,\n      timeoutMs,\n      transactionHash: transaction.hash,\n    });\n    const receipt = await raceAgainstTimeout(\n      this.client.adapter.getTransactionReceipt(transaction.hash),\n      timeoutMs,\n    );\n\n    return {\n      successful: receipt && receipt.status === 1,\n      meta: {\n        transaction,\n        receipt,\n      },\n      eventData,\n    };\n  }\n\n  _sendWithoutWaitingForMining(\n    transaction: Transaction,\n    timeoutMs: number,\n  ): ContractResponse<OutputValues> {\n    const eventDataPromise = this.client.getEventData({\n      events: this.eventHandlers,\n      timeoutMs,\n      transactionHash: transaction.hash,\n    });\n    const receiptPromise = raceAgainstTimeout(\n      this.client.adapter.getTransactionReceipt(transaction.hash),\n      timeoutMs,\n    );\n    const successfulPromise = new Promise(async (resolve, reject) => {\n      try {\n        const receipt = await receiptPromise;\n        resolve(receipt && receipt.status === 1);\n      } catch (error) {\n        reject(error.toString());\n      }\n    });\n    return {\n      successfulPromise,\n      meta: {\n        receiptPromise,\n        transaction,\n      },\n      eventDataPromise,\n    };\n  }\n\n  async _send(\n    callArgs: Array<any>,\n    options: SendOptions,\n  ): Promise<ContractResponse<OutputValues>> {\n    const {\n      timeoutMs,\n      waitForMining,\n      ...transactionOptions\n    } = this._getDefaultSendOptions(options);\n\n    const transaction = await this._sendTransaction(\n      callArgs,\n      transactionOptions,\n    );\n\n    return waitForMining\n      ? this._sendWithWaitingForMining(transaction, timeoutMs)\n      : this._sendWithoutWaitingForMining(transaction, timeoutMs);\n  }\n\n  async _sendTransaction(\n    callArgs: Array<any>,\n    transactionOptions: TransactionOptions,\n  ) {\n    return this.client.send(this.functionName, callArgs, transactionOptions);\n  }\n\n  /**\n   * Given send options, set default values for this Sender.\n   */\n  _getDefaultSendOptions(options: SendOptions) {\n    const { name: networkName } = this.client.adapter.provider;\n    // Allow a much longer timeout for mainnet transactions.\n    const minutes = networkName === 'mainnet' ? 60 : 5;\n\n    return Object.assign(\n      {},\n      {\n        timeoutMs: 1000 * 60 * minutes,\n        waitForMining: true,\n        ...(this._defaultGasLimit ? { gasLimit: this._defaultGasLimit } : null),\n      },\n      options,\n    );\n  }\n}\n"]}