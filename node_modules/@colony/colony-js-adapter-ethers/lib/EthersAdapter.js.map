{"version":3,"sources":["../src/EthersAdapter.js"],"names":["EthersAdapter","events","timeoutMs","transactionHash","mapEventToPromise","eventName","contract","handler","wrappedHandler","subscriptionPromise","Promise","args","resolve","addListener","removeListener","Object","getOwnPropertyNames","map","loader","provider","wallet","query","load","abi","address","bytecode","Error","contractParams","Contract","getDeployTransaction","eventPromises","constructor","getEventPromises","assign","all","entries","forEach","getTransactionReceipt","receipt","waitForTransaction","_getTransactionReceipt","toString","includes","messageHash","messageBytes","utils","arrayify","signMessage","signature","splitSignature","sigR","r","sigS","s","sigV","v","digest","recoveryParam","SigningKey","recover"],"mappings":"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","file":"EthersAdapter.js","sourcesContent":["/* @flow */\n\nimport ethers from 'ethers';\nimport { raceAgainstTimeout } from '@colony/colony-js-utils';\nimport type {\n  IContract,\n  IAdapter,\n  IProvider,\n  IWallet,\n  Event,\n  EventHandler,\n  EventHandlers,\n  Signature,\n  Transaction,\n} from '@colony/colony-js-adapter';\nimport type { Query } from '@colony/colony-js-contract-loader';\n\nimport ContractLoader from '@colony/colony-js-contract-loader';\n\nimport type { ConstructorArgs } from './flowtypes';\nimport EthersContract from './EthersContract';\n\nimport { DEFAULT_TRANSACTION_WAIT_TIMEOUT } from './defaults';\n\nexport default class EthersAdapter implements IAdapter {\n  loader: ContractLoader;\n  provider: IProvider;\n  wallet: IWallet;\n  static getEventPromises({\n    events,\n    timeoutMs,\n    transactionHash,\n  }: {\n    events: { [eventName: string]: EventHandler },\n    timeoutMs: number,\n    transactionHash: string,\n  }): Array<Promise<any>> {\n    const mapEventToPromise = eventName => {\n      const { contract, handler } = events[eventName];\n      let wrappedHandler;\n\n      const subscriptionPromise = new Promise(resolve => {\n        wrappedHandler = ({ args }: Event) => resolve(handler(args));\n        contract.addListener(eventName, wrappedHandler, transactionHash);\n      });\n\n      return raceAgainstTimeout(subscriptionPromise, timeoutMs, () =>\n        contract.removeListener(eventName, wrappedHandler, transactionHash),\n      );\n    };\n    return Object.getOwnPropertyNames(events).map(mapEventToPromise);\n  }\n  constructor({ loader, provider, wallet }: ConstructorArgs) {\n    this.loader = loader;\n    this.provider = provider;\n    this.wallet = wallet;\n  }\n  async getContract(query: Query): Promise<IContract> {\n    const { address, abi } =\n      (await this.loader.load(query, {\n        abi: true,\n        address: true,\n        bytecode: false,\n      })) || {};\n\n    if (typeof address !== 'string')\n      throw new Error('Unable to parse contract address');\n\n    return new EthersContract(address, abi, this.wallet);\n  }\n  async getContractDeployTransaction(\n    query: Query,\n    contractParams: Array<any>,\n  ): Promise<Transaction> {\n    const { abi, bytecode } = await this.loader.load(query, {\n      abi: true,\n      address: false,\n      bytecode: true,\n    });\n    return ethers.Contract.getDeployTransaction(\n      bytecode,\n      abi,\n      ...contractParams,\n    );\n  }\n  // XXX this isn't a static method because we can't define it as such\n  // in the Interface thanks to Flow\n  async getEventData({\n    events = {},\n    transactionHash,\n    timeoutMs,\n  }: {\n    events: EventHandlers,\n    timeoutMs: number,\n    transactionHash: string,\n  }): Promise<{}> {\n    const eventPromises = this.constructor.getEventPromises({\n      events,\n      timeoutMs,\n      transactionHash,\n    });\n    try {\n      // Wait for all success events to resolve, or reject on any error event\n      return Object.assign({}, ...(await Promise.all(eventPromises)));\n    } finally {\n      Object.entries(events).forEach(([eventName, { contract, handler }]) => {\n        contract.removeListener(eventName, handler, transactionHash);\n      });\n    }\n  }\n  async _getTransactionReceipt(transactionHash: string) {\n    const receipt = await this.provider.getTransactionReceipt(transactionHash);\n    if (receipt == null)\n      throw new Error(\n        `Transaction receipt not found (transaction: ${transactionHash})`,\n      );\n    return receipt;\n  }\n  async waitForTransaction(\n    transactionHash: string,\n    timeoutMs: number = DEFAULT_TRANSACTION_WAIT_TIMEOUT,\n  ) {\n    return raceAgainstTimeout(\n      this.provider.waitForTransaction(transactionHash),\n      timeoutMs,\n    );\n  }\n  async getTransactionReceipt(transactionHash: string, timeoutMs?: number) {\n    let receipt;\n    try {\n      // Attempt to get the receipt immediately; the transaction may have\n      // already been mined, or we're running on TestRPC with no mining time.\n      receipt = await this._getTransactionReceipt(transactionHash);\n    } catch (error) {\n      // Ignore the error if the receipt wasn't found\n      if (!error.toString().includes('Transaction receipt not found'))\n        throw error;\n    }\n\n    // Wait until the transaction has been mined, then get the receipt.\n    await this.waitForTransaction(transactionHash, timeoutMs);\n    receipt = this._getTransactionReceipt(transactionHash);\n    return receipt;\n  }\n  /**\n   * Sign a message hash (as binary) and return a split signature.\n   */\n  async signMessage(messageHash: string) {\n    const messageBytes = ethers.utils.arrayify(messageHash);\n    const signature = await this.wallet.signMessage(messageBytes);\n\n    const { r: sigR, s: sigS, v: sigV } = ethers.utils.splitSignature(\n      signature,\n    );\n    return {\n      sigR,\n      sigS,\n      sigV,\n    };\n  }\n\n  /**\n   * Given a message digest and a signature, recover the address used to\n   * sign the message.\n   */\n  // eslint-disable-next-line class-methods-use-this\n  ecRecover(digest: Array<number>, { sigR, sigS, sigV }: Signature): string {\n    // This method doesn't need to be static, but flow Interfaces don't\n    // support static methods.\n    const recoveryParam = sigV - 27;\n    return ethers.SigningKey.recover(digest, sigR, sigS, recoveryParam);\n  }\n}\n"]}